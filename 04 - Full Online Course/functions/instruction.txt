 'use strict';

 const functions = require('firebase-functions');
 // The logger SDK supports log entries as part of a wildcard import. For example
 // functions.logger.log("Hello from info. Here's an object:", someObj);
/*
logger.log() commands have the INFO log level.
logger.info() commands have the INFO log level.
logger.warn() commands have the ERROR log level.
logger.error() commands have the ERROR log level.
Internal system messages have the DEBUG log level.
With logger.write(), you can write log entries addition log severity levels of CRITICAL, ALERT, and EMERGENCY. See LogSeverity.

*/

 const admin = require('firebase-admin');
 admin.initializeApp();
 
 // https://firebase.google.com/docs/functions/writing-and-viewing-logs

 /*
 Cloud Logging offers a powerful suite of logs analysis tools that you can use to monitor your Cloud Functions. These tools are especially powerful when combined with custom logging.
 
 https://jayendrapatil.com/google-cloud-logging/
 User Logs
User logs are generated by user software, services, or applications and written to Cloud Logging using a logging agent, the Cloud Logging API, or the Cloud Logging client libraries
  * Agent logs
  * produced by logging agent installed that collects logs from user applications and VMs
  * covers log data from third party applications
  * charged beyond free limits
  * 30 day retention

Exporting involves writing a filter that selects the log entries to be exported, and choosing a destination from the following options:
Cloud Storage: JSON files stored in Cloud Storage buckets for long term retention
BigQuery: Tables created in BigQuery datasets. for analytics
Pub/Sub: JSON messages delivered to Pub/Sub topics to stream to other resources. Supports third-party integrations, such as Splunk
Another Google Cloud Cloud project: Log entries held in Cloud Logging logs buckets.

*/

 const { Logging } = require('@google-cloud/logging');
 const logging = new Logging({
   projectId: process.env.GCLOUD_PROJECT,
 });
 
 const { Stripe } = require('stripe');
 const stripe = new Stripe(functions.config().stripe.secret, {
   apiVersion: '2020-08-27',
 });
 
 /**
  * When a user is created, create a Stripe customer object for them.
  *
  * @see https://stripe.com/docs/payments/save-and-reuse#web-create-customer
  */
 exports.createStripeCustomer = functions.auth.user().onCreate(async (user) => {
   const customer = await stripe.customers.create({ email: user.email });
   const intent = await stripe.setupIntents.create({
     customer: customer.id,
   });
   await admin.firestore().collection('stripe_customers').doc(user.uid).set({
     customer_id: customer.id,
     setup_secret: intent.client_secret,
   });
   return;
 });
 
 /**
  * When adding the payment method ID on the client,
  * this function is triggered to retrieve the payment method details.
  */
 exports.addPaymentMethodDetails = functions.firestore
   .document('/stripe_customers/{userId}/payment_methods/{pushId}')
   .onCreate(async (snap, context) => {
     try {
       const paymentMethodId = snap.data().id;
       const paymentMethod = await stripe.paymentMethods.retrieve(
         paymentMethodId
       );
       await snap.ref.set(paymentMethod);
       // Create a new SetupIntent so the customer can add a new method next time.
       const intent = await stripe.setupIntents.create({
         customer: `${paymentMethod.customer}`,
       });
       await snap.ref.parent.parent.set(
         {
           setup_secret: intent.client_secret,
         },
         { merge: true }
       );
       return;
     } catch (error) {
       await snap.ref.set({ error: userFacingMessage(error) }, { merge: true });
       await reportError(error, { user: context.params.userId });
     }
   });
 
 /**
  * When a payment document is written on the client,
  * this function is triggered to create the payment in Stripe.
  *
  * @see https://stripe.com/docs/payments/save-and-reuse#web-create-payment-intent-off-session
  */
 
 // [START chargecustomer]
 
 exports.createStripePayment = functions.firestore
   .document('stripe_customers/{userId}/payments/{pushId}')
   .onCreate(async (snap, context) => {
     const { amount, currency, payment_method } = snap.data();
     try {
       // Look up the Stripe customer id.
       const customer = (await snap.ref.parent.parent.get()).data().customer_id;
       // Create a charge using the pushId as the idempotency key
       // to protect against double charges.
       const idempotencyKey = context.params.pushId;
       const payment = await stripe.paymentIntents.create(
         {
           amount,
           currency,
           customer,
           payment_method,
           off_session: false,
           confirm: true,
           confirmation_method: 'manual',
         },
         { idempotencyKey }
       );
       // If the result is successful, write it back to the database.
       await snap.ref.set(payment);
     } catch (error) {
       // We want to capture errors and render them in a user-friendly way, while
       // still logging an exception with StackDriver
       functions.logger.log(error);
       await snap.ref.set({ error: userFacingMessage(error) }, { merge: true });
       await reportError(error, { user: context.params.userId });
     }
   });
 
 // [END chargecustomer]
 
 /**
  * When 3D Secure is performed, we need to reconfirm the payment
  * after authentication has been performed.
  *
  * @see https://stripe.com/docs/payments/accept-a-payment-synchronously#web-confirm-payment
  */
 exports.confirmStripePayment = functions.firestore
   .document('stripe_customers/{userId}/payments/{pushId}')
   .onUpdate(async (change, context) => {
     if (change.after.data().status === 'requires_confirmation') {
       const payment = await stripe.paymentIntents.confirm(
         change.after.data().id
       );
       change.after.ref.set(payment);
     }
   });
 
 /**
  * When a user deletes their account, clean up after them
  */
 exports.cleanupUser = functions.auth.user().onDelete(async (user) => {
   const dbRef = admin.firestore().collection('stripe_customers');
   const customer = (await dbRef.doc(user.uid).get()).data();
   await stripe.customers.del(customer.customer_id);
   // Delete the customers payments & payment methods in firestore.
   const batch = admin.firestore().batch();
   const paymetsMethodsSnapshot = await dbRef
     .doc(user.uid)
     .collection('payment_methods')
     .get();
   paymetsMethodsSnapshot.forEach((snap) => batch.delete(snap.ref));
   const paymentsSnapshot = await dbRef
     .doc(user.uid)
     .collection('payments')
     .get();
   paymentsSnapshot.forEach((snap) => batch.delete(snap.ref));
 
   await batch.commit();
 
   await dbRef.doc(user.uid).delete();
   return;
 });
 
 /**
  * To keep on top of errors, we should raise a verbose error report with Stackdriver rather
  * than simply relying on functions.logger.error. This will calculate users affected + send you email
  * alerts, if you've opted into receiving them.
  */
 
 // [START reporterror]
 
 async function reportError(err, context = {}) {
   // This is the name of the StackDriver log stream that will receive the log
   // entry. This name can be any valid log stream name, but must contain "err"
   // in order for the error to be picked up by StackDriver Error Reporting.
   const logName = 'errors'; //my-log
   const log = logging.log(logName);
 
   // https://cloud.google.com/logging/docs/api/ref_v2beta1/rest/v2beta1/MonitoredResource
   const metadataError = {
     resource: {
       type: 'cloud_function',
       labels: { function_name: process.env.FUNCTION_NAME },
     },
   };
   // https://cloud.google.com/error-reporting/reference/rest/v1beta1/ErrorEvent
   const errorEvent = {
     message: err.stack,
     serviceContext: {
       service: process.env.FUNCTION_NAME,
       resourceType: 'cloud_function',
     },
     context: context,
   };
   const error_entry = log.entry(metadataError, errorEvent);

     // A json log entry with additional context
  const metadataJson = {
    severity: 'WARNING',
    labels: {
      foo: 'bar',
    },
    // A default log resource is added for some GCP environments
    // This log resource can be overwritten per spec:
    // https://cloud.google.com/logging/docs/reference/v2/rest/v2/MonitoredResource
    // resource: {
    //   type: 'global',
    // },
    resource: {
      type: 'cloud_function',
      labels: { function_name: process.env.FUNCTION_NAME },
    },
  };
  const messageJSONEvent = {
    name: 'King Arthur',
    quest: 'Find the Holy Grail',
    favorite_color: 'Blue',
  };

  const json_entry = log.entry(metadataJson, messageJSONEvent);
  
   // Write the error log entry: promise based function
   return new Promise((resolve, reject) => {
     log.write([error_entry, json_entry], (error) => {
       if (error) {
         return reject(error);
       }
       return resolve();
     });
   });

  /*
   async function writeLogEntry() {
    // Synchronously write the log entry
    await log.write(error_entry);
    // Synchronously batch write the log entries
    await log.write([error_entry, json_entry]);
    // Asynchronously let the logging library dispatch logs
    // log.write(error_entry);
    console.log(`Wrote to ${logName}`);
  }
  writeLogEntry();
  // https://github.com/googleapis/nodejs-logging/blob/master/samples/logs.js
  */

 }
 
 // [END reporterror]
 
 /**
  * Sanitize the error message for the user.
  */
 function userFacingMessage(error) {
   return error.type
     ? error.message
     : 'An error occurred, developers have been alerted';
 }

// Create and Deploy Your First Cloud Functions
// https://firebase.google.com/docs/functions/write-firebase-functions

exports.helloWorld = functions.https.onRequest((request, response) => {
  functions.logger.info("Hello logs!", {structuredData: true});
  response.send("Hello from Firebase!");
});
